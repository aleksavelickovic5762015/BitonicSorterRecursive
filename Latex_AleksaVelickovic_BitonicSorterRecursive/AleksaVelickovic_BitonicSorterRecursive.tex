\documentclass[12pt, a4paper]{article}
\usepackage[T1, T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[serbianc]{babel}

%\usepackage{geometry}
%\geometry{a4paper, margin=1in}
\usepackage[margin=1in]{geometry}

\usepackage{graphicx}
\usepackage{tocloft}
\usepackage[unicode, breaklinks]{hyperref}

%\usepackage{hyperref}
%\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

\usepackage{caption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{float}
\usepackage{minted}
\usepackage{verbatim}
\usepackage{cite}
\usepackage[nottoc]{tocbibind}
\usepackage{romannum}

%\usepackage[none]{hyphenat}
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

\bibliographystyle{ieeetr}
%\setlength{\bibsep}{0.0pt}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    filecolor=magenta,
    urlcolor=cyan,
}
\makeatletter
\g@addto@macro\UrlBreaks{\do\-}
%\g@addto@macro{\UrlBreaks}{\UrlOrds}
\makeatother

%\hyphenpenalty 10000

\newcommand{\CS}{C\nolinebreak\hspace{-.05em}\raisebox{.6ex}{\tiny\bf \#}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}

\usepackage{enumitem}
\usepackage[printonlyused]{acronym} %,withpage

\usepackage{chngcntr}
\counterwithin{figure}{section}

%\renewcommand{\thefigure}{\thesubsection.\arabic{figure}}
\renewcommand{\thefigure}{%
  \ifnum\value{subsection}=0 % If subsection is zero
    \thesection.%
  \else % If there's a subsection number
    \thesubsection.%
  \fi
  \arabic{figure}%
}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Дефиниција}[section]

\begin{document}
%\sloppy
\pagenumbering{gobble}

\begin{titlepage}
%\newgeometry{margin=1in}
%\fontsize{14}{×}
\vspace{0.5cm}
\center
\Large
Универзитет у Београду\\
Електротехнички факултет\\
\vspace{1.3cm}
\includegraphics[scale=0.27]{slike/etf}\\
\vspace{2.5cm}
\LARGE
\textbf{Хардверска дигитална мрежа за сортирање}\\
\Large
Мастер рад\\
%\vspace{5cm}
\vfill
\large
\flushleft Ментор: \hfill Студент:\\
\vspace{0.1cm}
доц.\ др Живојин Шуштран \hfill Алекса Величковић 2020/3358\\
%\vspace{0.1cm}
%Алекса Величковић 576/2015\\
%\vfill
\vspace{1.3cm}
\center
Београд, септембар 2023.\\
\vspace{1.3cm}
%\restoregeometry
\end{titlepage}

\tableofcontents
\newpage

\pagenumbering{arabic}
\section{Увод}
У овом раду ће бити описана рекурзивна имплементација хардверске дигиталне мреже за сортирање битоник сортер. Имплементација је урађена коришћењем језика за опис хардвера Чизел (Chisel). Чизел је базиран на програмском језику Скала и омогућава једноставније дефинисање хардвера од других језика (као Верилог) и прегледнији програмски код.

Занимљиво је да се у раду врши поређење са постојећим решењем где је битоник сортер имплементиран итеративно. Замена елемената се у том решењу врши инстанцирањем посебног модула који представља операцију поређења.

Логика решења приказаног у овом раду се базира на постојећој Пајтон имплементацији битоник сорта, али је постојало неколико ограничења да би се она применила у Чизелу. Такође, битно је разликовање променљивих или условних израза који припадају Скали и оних који припадају Чизела.
\newpage

\section{Коришћени алати}
\subsection{Скала}
Скала (Scala) је програмски језик који подржава и објектно-оријентисано и функционално програмирање. Дизајниран је да буде концизан и да надомести недостатке које има програмски језик Јава (Java) \cite{wiki_scala}.
Име Скала потиче од „скалабилан језик”. Језик је тако назван зато што је дизајниран да расте са потребама корисника. Скала ради на стандардној Јава платформи и ради беспрекорно са свим Јава библиотекама. Примена конструкта функционалног програмирања омогућава брзо стварање коришћењем једноставних делова, док конструкти објектно-оријентисаног програмирања омогућавају изградњу већих система и прилагођавање новим потребама \cite{odersky2016}.
Скала је популаран програмски језик и користе га популарне компаније као Goldman Sachs, Twitter, IBM, Verizon, Spotify, Netflix итд.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.27]{slike/scalaCompanies}
  \caption{Компаније које користе Скалу}
  \label{fig:scalaCompanies}
\end{figure}

Постоје многи софтверски алати који су написани у Скали или су надограђени на овом програмском језику као нпр.\ Apache Spark који се користи за обраду и анализу великог обима података у дистрибуираном окружењу. Такође, на слици \ref{fig:scalaDer} се може приметити и Чизел (Chisel), језик за пројектовање хардверских уређаја, који ће касније бити детаљније описан и који је коришћен у овом раду.
\begin{figure}[H]
  \centering
      \includegraphics[scale=0.27]{slike/scalaDer}
  \caption{Окружења која користе Скалу}
  \label{fig:scalaDer}
\end{figure}

\subsubsection{Функције вишег реда}
\ac{fvr} су општи концепт који се јавља како у функционалном програмирању тако и математици. Функционални језици третирају функције као „грађане првог реда”, а то значи да:
\begin{itemize}
 \item функција може бити прослеђена као параметар другој функцији
 \item функција може бити резултат друге функције
\end{itemize}

Пример употребе \acs{fvr} за сумирање \cite{courseraHOF}:
\begin{minted}{scala}
def sum(f: Int => Int, a: Int, b: Int): Int =
  if a > b then 0
  else f(a) + sum(f, a + 1, b)

def id(x: Int): Int = x
def cube(x: Int): Int = x * x * x
def fact(x: Int): Int = if x == 0 then 1 else x * fact(x - 1)

def sumInts(a: Int, b: Int) = sum(id, a, b)
def sumCubes(a: Int, b: Int) = sum(cube, a, b)
def sumFactorials(a: Int, b: Int) = sum(fact, a, b)
\end{minted}

Овде се може приметити да функција \verb+sum()+ користи функцију \verb+f()+  као параметар, такође има и доњу границу \verb+a+ и горњу границу \verb+b+. Посебно су дефинисане функције \verb+sumInts()+ (сума бројева), \verb+sumCubes()+ (сума кубних вредности) и \verb+sumCubes()+ (сума факторијела бројева) на опсегу од \verb+a+ до \verb+b+. Може се приметити да су једине разлике њихових дефиниција функције која се прослеђује као аргументи \verb+id()+, \verb+cube()+ и \verb+fact()+.
Такође, функције \verb+sumInts()+ (сума бројева) и \verb+sumCubes()+ је могуће дефинисати и употребом \textit{Анонимних функција}:
\begin{minted}{scala}
def sumInts(a: Int, b: Int) = sum(x => x, a, b)
def sumCubes(a: Int, b: Int) = sum(x => x * x * x, a, b)
\end{minted}
Овако се може избећи писање великог броја кратких функција. Функцију \verb+sum()+ је могуће дефинисати и тако да није неопходно прослеђивати \verb+a+ и \verb+b+ при дефинисању функција за различита сумирања.
\begin{minted}{scala}
def sum(f: Int => Int): (Int, Int) => Int =
  def sumF(a: Int, b: Int): Int =
    if a > b then 0
    else f(a) + sumF(a + 1, b)
  sumF
// или скраћено
def sum(f: Int => Int)(a: Int, b: Int): Int =
  if a > b then 0 else f(a) + sum(f)(a + 1, b)
// где би сумирање кубова било овако дефинисано
def sumCubes = sum(x => x * x * x)
// или чак ни то није неопходно..
sum (cube) (1, 10)
\end{minted}
Овакав стил дефинисања и примене функција, где се функција са више параметара може представити у виду секвенце функција једног параметра, назива се \textbf{керификација} (currying).

\newpage

\subsection{Чизел}
Чизел (Chisel - Constructing Hardware in a Scala Embedded Language) је језик за опис хардвера заснован на Скали. Чизел наслеђује аспекте објектно-оријентисаног и функционалног програмирања Скале за опис дигиталног хардвера. Коришћење Скале као основе омогућава опис генератора кола. Чизел код којим су описана кола може бити претворен у Верилог (Verilog) за синтезу и симулацију \cite{wiki_chisel}.

Омогућава корисницима да конструишу хардвер управљајући и повезујући Скала објекте да би се направио граф жељеног хардвера. Чизел бекенд потом анализира резултујући граф да би се добио брз,
циклусно-прецизан \CC\phantom{a}симулатор, који одмах потом може да комуницира са Скала тестним окружењем или Верилог синтезом која ће бити процесирана на FPGA интегрисаном колу. Чизел дозвољава генератору хардвера да изврши различита израчунавања у Скали над улазним параметрима током израде графа хардвера. Додатно, програмери могу да искористе одлике функционалног програмирања у Скали за опис апстракција хардвера (нпр.\ имплементација ФИР филтера коришћењем \verb+map+ и \verb+reduce+ функција) и Јава стандардних библиотека (нпр.\ претварање бројева са покретним зарезом у или из репрезентације битова која би се користила у тестном окружењу) као начине за поједностављивање свеукупног развоја хардвера и верификације.
% cite
%
% Остали језици, као SystemVerilog нуде неке могућности које нуди и Чизел као ААААААААААА. Међутим, пошто су ови језици фокусирани на опис хардвера, издвајање делова са генераторима у оне које раде само са параметрима и оне које описују жељени хардвер је више изазовно. Конкретно, имплементација решавача ограничења (constraint solver) се не преводи тако добро у друге језике. Овај решавач, у потпуности написан у Скали,
% користи спецификацију акцелератора (величина FFT, радикс, и број извршних јединица) и производи листу инструкција и мапирања меморије статички гарантоване да неће показивати опасности од меморијских колизија или конфликата банака. Затим, Чизел компоненте генератора користе ову листу за писање ROM-ова за превођење инструкција и IO адреса. Имплементација у другим језицима би изискивала одржавање решавача ограничења ван генератора и комуникацију путем текстуалних фајлова; међутим, ово представља изазове ако интерфејси постану десинхронизовани додавањем функционалности генератора. Такође, Чизел гарантује да се сви описани графикони могу анализирати у синтезибилни Верилог, док се сви системски Верилог аспекти не гарантују да су синтезибилни.

Отклањање грешака поквареног дизајна хардвера у Чизелу може бити изазовно. Чизел често иде предалеко са тим да се пише сажет програмски код науштрб безбедности. Тако, корисник може да погреши у куцању при дефинисању хардвера, а да не добије никакве грешке. Такође, доста грешака које Чизел враћа су веома нејасне, где само пише ``assertion failed''. На пример, декларисање литерала (непроменљиве вредности) уместо порта унутар УИ (IO) декларација је грешка коју би Чизел ухватио. Међутим, порука о грешци која се добија је донекле бескорисна \cite{berkeley_twigg}.

\subsubsection{Генератори кола и условни изрази}
Сви језици за опис хардвера подржавају писање појединачних инстанци. Међутим, писање инстанци је заморно. Верлилог омогућава ограничену параметризацију, као број битова и \verb+generate+ израз, али само толико. Пошто није могуће написати генератор у Верилогу, то би значило да треба да напишемо нову инстанцу, што би дуплирало величину програмског кода.
Генератори би требало (у идеалном случају) да их је могуће направити, да су моћни и да омогућавају прецизну контролу над генерисаним дизајном. Провера грешака је неопходна да бисмо били сигурни ли је композиција дозвољена; без тога, отклањање грешака је тешко. Ово тражи да језик генератора разуме семантику дизајна тј.\ да зна шта јесте, а шта није дозвољено. Такође, генератор не би требало да буде преопширан! Желимо да програм генератора сажето изрази више различитих дизајна, без потребе да се преправља у \verb+if+ условима за сваку инстанцу \cite{git_chisel}.

У наставку је приказан једноставан пример \verb+Passthrough+, који има 4-битни улаз \verb+in+ и 4-битни излаз \verb+out+. Модул повезује \verb+in+ и \verb+out+, па \verb+in+ управља \verb+out+-ом.
%\newpage
\begin{minted}{scala}
class Passthrough extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(4.W))
    val out = Output(UInt(4.W))
  })
  io.out := io.in
}
\end{minted}
\verb+Modul+ је уграђена Chisel класа коју сви хардвер модули морају да наследе. Сви улазни и излазни портови се декларишу у посебној \verb+io+ \verb+val+. Мора да се зове \verb+io+, и мора да буде \verb+IO+ објекат или инстанца у форми \verb+IO(_instantiated_bundle_)+.
\begin{minted}{scala}
new Bundle {
    val in = Input(...)
    val out = Output(...)
}
\end{minted}

Декларише се нова хардверска структура типа (\verb+Bundle+) која садржи сигнале \verb+in+ и \verb+out+ са одговарајућим смеровима \verb+Input+ и \verb+Output+, редом. \verb+UInt(4.W)+ представља тип сигнала, у овом случају неозначени (unsigned) цео број ширине 4. Улазни порт се повезује са излазним изразом \verb+io.out := io.in+, и тако \verb+io.in+ управља \verb+io.out+.

Након декларисања Чизел модула, користимо Скалу да позовемо Чизел компајлер да преведе Чизел \verb+Passthrough+ у Верилог \verb+Passthrough+. Овај процес се назива обрађивање (elaboration).
\begin{minted}{scala}
println(getVerilog(new Passthrough))
\end{minted}

Као било која Скала класа и Чизел модул би могао да прими неке параметре. У наставку је приказан пример генератор модула, где се дефинише нова класа \verb+PassthroughGenerator+ која прима целобројну вредност \verb+width+ која одређује ширине улазног и излазног порта:
\begin{minted}{scala}
class PassthroughGenerator(width: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(width.W))
    val out = Output(UInt(width.W))
  })
  io.out := io.in
}

println(getVerilog(new PassthroughGenerator(10)))
println(getVerilog(new PassthroughGenerator(20)))
\end{minted}
Може се приметити да Верилог користи различит број битова за улаз/излаз зависно од параметра \verb+width+.
\begin{minted}{verilog}
//Elaborating design...
//Done elaborating.
module PassthroughGenerator(
  input        clock,
  input        reset,
  input  [9:0] io_in,
  output [9:0] io_out
);
  assign io_out = io_in; // @[cmd4.sc 6:10]
endmodule

//Elaborating design...
//Done elaborating.
module PassthroughGenerator(
  input         clock,
  input         reset,
  input  [19:0] io_in,
  output [19:0] io_out
);
  assign io_out = io_in; // @[cmd4.sc 6:10]
endmodule
\end{minted}
% \verb++
Пошто су Чизел модули нормалне Скала класе, можемо да искористимо предност конструктора Скала класа да параметризујемо обрађивање дизајна. Још једном, ову параметризацију омогућава Скала, не Чизел. Пошто \verb+PassthroughGenerator+ не описује само један модул, већ описује породицу модула са параметром \verb+width+, овај модул представља један \textbf{генератор}.

Основни условни изрази у Чизелу су \verb+when+, \verb+elsewhen+ и \verb+otherwise+. За разлику од \verb+if+ услова у Скали, овде се не враћају вредности на крају делова кода везаних за \verb+when+. На пример, израз \verb+val result = when(squareIt) { x * x }.otherwise { x }+ неће радити. Начин да се заобиђе ово ограничење је \verb+Wire+ конструкт. \verb+Wire+ се може налазити на десној или на левој страни \verb+:=+ оператора. Следећи пример зависно од вредности улазног селектора рачуна један од три полинома $x^2 - 2x + 1$, $2x^2 + 6x + 3$ или $4x^2 - 10x - 5$:
\begin{minted}{scala}
class Polynomial extends Module {
  val io = IO(new Bundle {
    val select = Input(UInt(2.W))
    val x = Input(SInt(32.W))
    val fOfX = Output(SInt(32.W))
  })
  val result = Wire(SInt(32.W))
  val square = Wire(SInt(32.W))
  square := io.x * io.x
  when(io.select === 0.U) {
    result := (square - (2.S * io.x)) + 1.S
  }.elsewhen(io.select === 1.U) {
    result := (2.S * square) + (6.S * io.x) + 3.S
  }.otherwise {
    result := (4.S * square) - (10.S * io.x) - 5.S
  }

  io.fOfX := result
}
\end{minted}

\newpage
\section{Мреже за сортирање}
Сортирање је одувек био фундаментални проблем у рачунарству и детаљно је изучаван. Постоје разни методи сортирања за софтверске и хардверске имплементације. У случају хардверских, постоји компромис између пропусне способности и цене (тј.\ логике и меморије за сортирање $n$ елемената). Два популарна решења су битоник мрежа за сортирање и линеарни сортер. За листу дужине $n$, битоник сортер захтева $\mathcal{O}(n \log^2 n)$ логике и меморије и може да сортира $n$ елемената по циклусу; линеарни сортер захтева $\mathcal{O}(n)$ логике и меморије и сортира $n$ елемената за $n$ циклуса \cite{zuluaga2016}.

Сада ће бити дефинисани неопходни кључни термини за описивање својстава различитих решења.
\begin{definition}[Пропуштање]
Замислимо хардверски дизајн који мора да прими $n$ речи података (и да врати $n$ речи података на излазу). Ако прими (и врати) $w$ речи по тактном циклусу током $n/w$ узастопних циклуса, ово се назива \textit{пропуштање} (\textit{streaming}), где је $w$ пропусна ширина.
\end{definition}
Имплементирањем дизајна са пропусном ширином $w$ мањом од $n$ (број речи који се сортира), цена и У/И пропусна способност система се смањују.
\begin{definition}[Потпуно пропуштање]
Дизајн који константно може да прима улазни ток података без икаквог времена чекања између два улазна скупа се назива \textit{потпуно пропустан} (\textit{fully streaming}) дизајн.
\end{definition}
Потпуно пропусна мрежа за сортирање пропусне ширине $w$ ће имати пропусну способност $w$ речи по тактном циклусу. Обично се може очекивати да потпуно пропустан дизајн захтева више ресурса од дизајна која није потпуно пропустан, зато што за исто време обрађује више података.

\textit{Мреже за сортирање} паралелно обрађују листу $n$ улазних елемената кроз више нивоа тако да је на последњем нивоу улазна листа сортирана. Током сваког нивоа паралелно се изводе поређења и пермутације. Број нивоа који је потребан да се добије сортирана листа и број поређења по нивоу одређују цену мреже. Број улазних вредности је степен броја два: $n = 2^t$.

Слика \ref{fig:bitonicStages} показује \textit{битоник} (\textit{bitonic}) мрежу за сортирање \cite{bitonicBatcher}. Има осам улазних елемената. Оператор $S_2$ сортира два улаза у растућем редоследу. Мреже за сортирање могу да постигну веома велику пропусност, зато што су потпуно пропусне, где је ширина протока $n$. Обично су повезане тако да се одржи разумна брзина такта и тада је потребно $\mathcal{O}(n \log^2 n)$ флип-флопова за меморију.
\begin{figure}[H]
  \centering
      \includegraphics[scale=0.24]{slike/bitonicStages.png}
  \caption{(a) Битоник мрежа за сортирање за улазну величину скупа $n = 8$ \mbox{(b) Двоулазни} сортер $S_2$ је градивна јединица у мрежама за сортирање}
  \label{fig:bitonicStages}
\end{figure}
Као што се може приметири на слици \ref{fig:bitonicStages}, битоник мрежа за сортирање има константну структуру и може се конструисати рекурзивно. Сортира се $n$ елемената у $\log_{2}(n)(\log_{2}(n)+1)/2$ нивоа са $n/2$ паралелних $S_2$ операција, па је потребно $\mathcal{O}(n\log(n)^2)$ операција поређења. Кенет Едвард Бечер (Kenneth Edward Batcher) је објавио овај алгоритам 1968.\ године, а такође је развио и \textit{пар-непар} (\textit{odd-even}) мреже за сортирање, које су имају мање константну структуру, али захтевају мало мање операција поређења.
Пар-непар и битоник мреже за сортирање су остале најпопуларнија решења због своје једноставности и скоро оптималне цене и перформанси.

\textit{Линеарни сортер} је линеарни низ $n$ чворова који сортирају $n$ вредности, где $n$ није ограничено да мора да буде степен броја два. Сваки чвор се састоји од флип-флопа и опеаратора поређења. Асимптотско време и логичка цена линеарних сортера је $\mathcal{O}(n)$ и оне су потпуно пропусне са пропусном ширином 1.
%сортирање спајањем ()

\subsection{Битоник сортер}
Низ бројева може да се назове битоник ако се састоји од два монотона низа, једног растућег и другог опадајућег. Такође, низ остаје битоник ако је подељен било где и два дела замењена.

Ако је низ $2n$ бројева $a_1, a_2, \dots, a_{2n}$ битоник и ако направимо два низа од $n$ бројева
\begin{equation}
 min(a_1, a_{n+1}), min(a_2, a_{n+2}), \dots, min(a_n, a_{2n})
 \label{eq:bit1}
\end{equation}
\begin{equation}
 max(a_1, a_{n+1}), max(a_2, a_{n+2}), \dots, max(a_n, a_{2n})
 \label{eq:bit2}
\end{equation}
онда су оба ова низа битоник и ниједан број из (\ref{eq:bit1}) није већи ни од једног броја из низа (\ref{eq:bit2}). Одавде се долази до итеративног правила приказаног на слици \ref{fig:batcherIter}. Битоник сортер за $2n$ бројева може бити кон од $n$ елемената за поређење и два битоник сортера за $n$ бројева. Елементи за операцију поређења формирају (\ref{eq:bit1}) и (\ref{eq:bit2}) и пошто су обе битоник потом су сортиране са два битоник сортера за $n$ бројева. Пошто ниједан број из (\ref{eq:bit1}) није већи ни од једног броја из низа (\ref{eq:bit2}) излаз из једног битоник сортера је доња половина сортираног низа, а излаз другог сортера је горња половина \cite{bitonicBatcher}.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.4]{slike/batcherIter}
  \caption{Итеративно правило за битоник сортере}
  \label{fig:batcherIter}
\end{figure}

Битоник сортер за два броја је само један елемент за поређење и коришћењем итеративног правила битоник сортери за $2^p$ бројева могу бити конструисани за било које $p$. Слика \ref{fig:batcher4_8num} приказује приказује сортере за четири и осам бројева. Битоник сортер за $2^p$ бројева захтева $p$ нивоа по $2^{p-1}$ елемената, укупно $p2^{p-1}$. Може да се искористи као мрежа за спајање за било које две листе укупне дужине $2^p$.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.3]{slike/batcher4_8num}
  \caption{Конструкција битоник сортера за четири и осам бројева}
  \label{fig:batcher4_8num}
\end{figure}

Велики битоник сортери могу бити конструисани из више мањих битоник сортера. На слици \ref{fig:batcher16num} је приказан битоник сортер за 16 бројева конструисаног од осам битоник сортера за 4 броја.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.3]{slike/batcher16num}
  \caption{Битоник сортер за 16 бројева конструисаног од осам битоник сортера за 4 броја}
  \label{fig:batcher16num}
\end{figure}

Следећа слика боље приказује како ради алгоритам. 16 бројева се налази на улазу на левој страни и прелазе преко 16 хоризонталних жица до излаза на десној страни. Мрежа сортира елементе, тако да се највећи налази на дну.

Стрелице представљају операције поређења и показују ка већем броју. Уокверни правоугаоници у боји немају утицај на рад алгоритма, само олакшавају разумевање.
\begin{figure}[H]
  \centering
      \includegraphics[scale=0.7]{slike/BitonicSort1.pdf}
  \caption{Приказ рада битоник алгоритма са 16 бројева на улазу}
  \label{fig:bitonicSortWiki}
\end{figure}
Ако посматрају црвени правоугаоници, може се приметити да се сваки улаз из горње половине пореди са одговарајућим улазом који се налази у доњој половини правоугаоника, где су стрелице усмерене надоле ако су у питању тамноцрвени правоугоници или нагоре код светлоцрвених.
%
Ако бројеви на улазу формирају битоник низ, онда ће се на излазу нађи два битоник низа. Горња и доња половина излаза ће бити битоник, где ће сваки број горње половине бити мањи (или једнак) од сваког из доње (у тамноцрвеним) или обрнуто (у светлоцрвеним) \cite{wiki_bitonic}.
%
\begin{figure}[H]
  \centering
      \includegraphics[scale=0.25]{slike/leptir}
  \caption{Топологија лептира}
  \label{fig:leptir}
\end{figure}
Црвени правоугаоници формирају плаве и зелене. Црвени примају цео улазни низ, потом половину резултата, потом половину тих резултата итд. Све стрелице показују надоле (плави) ил нагоре (зелени). Ова структура је позната као лептир (buterfly) мрежа. Топологија лептира је приказана на слици \ref{fig:leptir}. Ако се на улазу у овакав правоугаоник нађе битнок низ, онда ће излаз бити сортиран у растућем поретку у слчају плавих правоугаоника или опадајућем код зелених. Када се број налази на улазу у зелени или плави правоугаоник, онда ће први црвени да га сортира у праву половину листе. Потом пролази кроз мањи црвени правоугаоник који га сортира у праву четвртину листе унутар те половине итд. Излаз из црвеног или плавог правоугаоника је потпуно сортиран.

Коришћењем плавих и зелених правоугаоника се може направити цела мрежа. Излаз из сваког зеленог и плавог правоугаоника је сортиран низ, па ће излаз сваког пара суседних низова бити битоник, зато што је горњи плави, а доњи зелени. Свака колона плавих и зелених правоугаоника узима $N$ сортираних низова и спаја их у паровове тако да се добије $N/2$ битоник низова, који се потом сортирају унутар правоугаоника те колоне да се добије $N/2$ низова. Овај процес почиње од сортиране листе која садржи један елемент и наставља се кроз све колоне док се у последњој колони не споје у једну сортирану листу. Пошто је последњи ниво плави, коначна листа ће имати највећи елемент на дну. \cite{wiki_bitonic}.

\newpage

\section{Постојећа решења}
%Поглавље \ref{sec:a_prilog}

Сада ће бити приказане две имплементације које су биле основа за израду оне која је приказана у овом раду.

\subsection{Итеративна имплементација битоник сортера у Чизелу}
\hyperref[sec:a_prilog]{Прилог} садржи програмски код итеративне имплементације битоник сортера у Чизелу \cite{git_freeChipsBitonic}.
Овај програмски код дефинише хардверски модул за извршавање битоник сортирања на броју елемената који је степен броја 2 користећи \verb+Swapper+ модуле за поређење елемената. Дати примери показују како користити битоник сортер модул за конкретне типове података и величине. Сада следи објашњење програмског кода:

\begin{enumerate}
\item Увозе се Чизел библиотеке и дефинише се пакет за битоник сортирање

\item Класа \verb+Swapper+ дефинише хардверски модул за замену два улазна елемента на основу функције поређења. Овај модул има два улаза (\verb+a0+ и \verb+a1+) и два излаза (\verb+z0+ и \verb+z1+).
\begin{minted}{scala}
when(lt(io.a1, io.a0)) {
  io.z0 := io.a1
  io.z1 := io.a0
}.otherwise {
  io.z0 := io.a0
  io.z1 := io.a1}
\end{minted}


\item Креира се објекат \verb+BitonicSorter+, који је фабрика за креирање битоник сортер хардверских модула. Он прима \verb+IndexedSeq+ (Indexed Sequence) која садржи опционе улазне елеменате \verb+a+ и функцију \verb+factory()+ за креирање \verb+Swapper+ модула. Функција проверава да ли је број елемената за сортирање степен броја 2 и затим врши сортирање елемената користећи битоник алгоритам за сортирање.

\begin{itemize}
\item \verb+insertSorter+ је помоћна функција која врши сортирање уметањем у опсегу елемената у a задатим са \verb+lo+ и \verb+hi+. Она врши замену елемената користећи \verb+Swapper+ модуле на основу функције поређења \verb+lt+.

\item Главна логика сортирања се извршава у угњежденој петљи, где \verb+i+ представља битну позицију која
се разматра, \verb+j+ варира од \verb+i+ до \verb+0+, и \verb+k0+ и \verb+k1+ итерирају кроз елементе који требају да се пореде.

\item Унутар петље се проверава да ли је потребна замена елемената користећи \verb+Swapper+ модуле на основу битних позиција и функције поређења.

\item Резултат је сортирана \verb+IndexedSeq+ опционих елемената.
\end{itemize}

\begin{minted}{scala}
(for {
      i <- 0 until log2Up(a.length)
      j <- i to 0 by -1
      k0 <- a.indices by (2 << j)
      k1 <- 0 until 1 << j
    } yield {
      val lo = k0 + k1
      val hi = lo + (1 << j)
      if ((lo >> (i + 1)) % 2 == 0) (lo, hi) else (hi, lo)
    }).foldLeft(a) { case (s, (l, h)) => insertSorter(s, l, h) }
\end{minted}


\item Класа \verb+SorterModuleIfc+ дефинише интерфејс за битоник сортер модул. Прима број елемената \verb+n+ и прототип \verb+proto+ за елементе.

\item Дефинише се класа \verb+BitonicSorterModule+ која проширује \verb+SorterModuleIfc+. Ова класа представља битоник сортер модул и прима број елемената \verb+n+, прототип \verb+proto+, и функцију поређења \verb+lt+.

\begin{itemize}
\item Креира се \verb+IndexedSeq+ опционих елемената \verb+a+, иницијализујући га улазним елементима \verb+io.a+. Величина \verb+a+ је постављена на следећи степен броја 2 који је већи или једнак \verb+io.a.length+.

\item Сортирају се елементи \verb+a+ користећи фабрику \verb+BitonicSorter+, наводећи прототип и функцију поређења. Резултат је сортиран \verb+IndexedSeq+ опционих елемената.

\item Сортирани елементи се додељују излазу \verb+io.z+.
\end{itemize}

\begin{minted}{scala}
class BitonicSorterModule[T <: Data](n: Int, proto: T,
            lt: (T, T) => Bool) extends SorterModuleIfc(n, proto) {
private val a = IndexedSeq.tabulate(1 << log2Up(io.a.length))
                        { i => if (i < n) Some(io.a(i)) else None }
io.z := VecInit(BitonicSorter(a, () => new Swapper(proto.cloneType, lt))
                                          .slice(0, n).map(_.get))
}
\end{minted}


\item Програмски код садржи примере позива кода за генерисање за битоник сортер модула. Дата су два примера за сортирање 64 и 384 елемената 8-битних неозначених целих бројева (\verb+UInt8+) користећи \verb+BitonicSorterModule+. Ови примери генеришу SystemVerilog излаз користећи \verb+ChiselStage+ из Чизела и прослеђују тип и функцију поређења као аргументе.
\begin{minted}{scala}
object BitonicSorterUInt8_64Driver extends App {(new ChiselStage)
          .emitSystemVerilog(new BitonicSorterModule(64, UInt(8.W),
                                (x: UInt, y: UInt) => x < y), args)
}
\end{minted}

\end{enumerate}

\newpage
\subsubsection{Анализа рада итеративне имплементације}
Као што је претходно назначено, главна логика сортирања извршава се у угњежденој петљи, која је изнад приказана.
\begin{table}[H]
\centering
 \begin{tabular}{| c c | c c | c c | c c | c c | c c |}
  \hline
  l & h & l & h & l & h & l & h & l & h & l & h \\
  \hline
  0 & 1 & 0 & 2 & 0 & 1 & 0 & 4 & 0 & 2 & 0 & 1 \\
  3 & 2 & 1 & 3 & 2 & 3 & 1 & 5 & 1 & 3 & 2 & 3 \\
  4 & 5 & 6 & 4 & 5 & 4 & 2 & 6 & 4 & 6 & 4 & 5 \\
  7 & 6 & 7 & 5 & 7 & 6 & 3 & 7 & 5 & 7 & 6 & 7 \\
  \hline
 \end{tabular}
 \caption{Парови индекса бројева који се упоређују}
 \label{tab:index}
\end{table}
Ако бисмо посматрали пример да на улазу имамо низ од осам бројева, и ако бисмо генерисали парове индекса бројева унутар тог низа које је потребно поредити у сваком нивоу (табела \ref{tab:index}), битоник мрежа за сортирање би изгледала као на слици \ref{fig:bitonicIter}.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.7]{slike/bitonicIter.pdf}
  \caption{Битоник мрежа за сортирање - итеративна имплементација}
  \label{fig:bitonicIter}
\end{figure}

Занимљиво је приметити да је ова мрежа другачија од оне приказане на \mbox{слици \ref{fig:bitonicStages}}. Има исти број нивоа паралелног извршавања операција поређења, али се везе између неких нивоа разликују.

\newpage
На слици \ref{fig:visualizeIter} је приказана визуализација кола извршавањем команде \verb+visualize(()+ => \verb+new BitonicSorterModule(8, UInt(8.W), ...))+

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.4]{slike/visualizeIter}
  \caption{Визуализација итеративне имплементације}
  \label{fig:visualizeIter}
\end{figure}

Може се приметити да су парови који се пореде исти као у табели \ref{tab:index}.

\newpage
\subsection{Рекурзивна имплементација у Пајтону}

\hyperref[sec:b_prilog]{Прилог} садржи програмски код рекурзивне имплементације битоник сортера у Пајтону \cite{geeks}.

% Програм функционише само када је величина улазних података степен броја 2. Параметар \verb+dir+ указује смер сортирања, растући или опадајући. Ако услов \verb+a[i] > a[j]+ одговара изабраном смеру, онда се вредности \verb+a[i]+ и \verb+a[j]+ замењују.
%
% Функција \verb+bitonicMerge+ рекурзивно сортира битоник низ у растућем редоследу (ако је \verb+dir = 1+) или у опадајућем редоследу (ако је \verb+dir = 0+). Низ који се сортира почиње на индексу \verb+low+, а \verb+cnt+ је број елемената који треба сортирати.
%
% Ова функција прво производи битонички низ рекурзивним сортирањем његових две половине у супротним редоследима, а затим позива функцију "bitonicMerge" да их уједини у исти редослед.
%
% Позива се функција "bitonicSort" која сортира целокупни низ дужине "N" у РАСТУЋЕМ редоследу.
Сада следи објашњење програмског кода:

\begin{enumerate}
\item \verb+compAndSwap(a, i, j, dire)+ функција служи за упоређивање и замену два елемента у низу a на позицијама \verb+i+ и \verb+j+ у зависности од смера сортирања (уколико је \verb+dire+ једнак 1, онда сортира у растућем редоследу, а уколико је 0, онда сортира у опадајућем редоследу).

\item \verb+bitonicMerge(a, low, cnt, dire)+ функција рекурзивно сортира битонички низ у растућем или опадајућем редоследу, у зависности од вредности параметра \verb+dire+. Низ се сортира почевши од позиције \verb+low+, а параметар \verb+cnt+ представља број елемената који се сортирају.
\begin{minted}{python}
def bitonicMerge(a, low, cnt, dire):
  if cnt > 1:
    k = cnt//2
    for i in range(low , low+k):
        compAndSwap(a, i, i+k, dire)
    bitonicMerge(a, low, k, dire)
    bitonicMerge(a, low+k, k, dire)
\end{minted}
\item \verb+bitonicSort(a, low, cnt, dire)+ функција прво производи битонички низ рекурзивним сортирањем његових две половине у супротним редоследима, а затим позива функцију \verb+bitonicMerge+ да их уједини у исти редослед.
\begin{minted}{python}
def bitonicSort(a, low, cnt,dire):
  if cnt > 1:
    k = cnt//2
    bitonicSort(a, low, k, 1)
    bitonicSort(a, low+k, k, 0)
    bitonicMerge(a, low, cnt, dire)
\end{minted}


\item Из функције \verb+sort(a, N, up)+ се позива сортирање целокупног низа \verb+a+ дужине \verb+N+ у растућем или опадајућем редоследу, у зависности од вредности параметра \verb+up+.

\item Главни део програма почиње креирањем низа \verb+a+ који треба сортирати и подешава величину низа \verb+n+ и смер сортирања \verb+up+. Затим се позива функција \verb+sort(a, n, up)+ да изврши сортирање низа, и на крају се исписује сортиран низ.

\end{enumerate}

\newpage
\section{Рекурзивна имплементација битоник сортера у Чизелу - резлтат рада}

\hyperref[sec:c_prilog]{Прилог} садржи програмски код рекурзивне имплементације битоник сортера у Чизелу која је изложена у овом раду.
 Две имплементације описане у претходном поглављу су коришћене као основа за израду ове, где је прва коришћена као референца за синтаксу Чизела, а друга као логичка основа. Оно што је било изазовно је размевање начина рада итеративне имплементације где се прави посебна инстанца модула за замену два елемента \verb+Swapper+ и излаз додељује новом низу, који је повратна вредност функцкије \verb+insertSorter()+. То значи да приступ примењен у рекурзивној Пајтон имплементацији није могућ а да коло истовремено буде секвенцијално, јер се ту мења улазни низ. Потребно је било написати рекурзивну имплементацију у Чизелу где функције \verb+sort+, \verb+bitonicSort+ и \verb+bitonicMerge+ као повратну вредност имају низ тј.\ \verb+IndexedSeq[Option[T]]+, а рекурзивним позивима функција се прослеђују само делови улазног низа.

Да би се генерисала нова листа са замењеним (свапованим) елементима у одговарајућем редоследу, у \verb+bitonicMerge()+ функцији, искорићена је \verb+foldLeft()+ функција, која извршава функцију \verb+swapIfNecessary()+.

\begin{minted}{scala}
if (length > 1) {
  val half = length / 2
  val indices = 0 until half
  val swappedSeq = indices.foldLeft(arr) { (seq, i) =>
    swapIfNecessary(seq, i, ascending, lt)
  }
\end{minted}

Сада се долази до проблема саме замене елемената и на овом примеру се може видети како су Скала и Чизел сједињени. Наиме, функција \verb+swapIfNecessary()+ мора имати повратну вредност и не може се враћати унутар Чизел \verb+when+ блока, а потребно је користити \verb+when+ зато што вршимо замену на основу Чизел \verb+Bool+ вредности, и њему дефинисати вредност неког сигнала, притом Скала \verb+if+ услов се може само користи уз Скала \verb+Boolean+.

\begin{minted}{scala}
val m = Module(new Passthrough(si.cloneType))
val swapNeeded = lt(sj, si) === ascending
when(swapNeeded) {
  m.io.a0 := sj
  m.io.a1 := si
}.otherwise {
  m.io.a0 := si
  m.io.a1 := sj
}
seq.updated(i, Some(m.io.z0)).updated(j, Some(m.io.z1))
\end{minted}

На крају, прави се инстанца једноставног модула \verb+Passthrough+ који само прослеђује вредности са улаза, и излаз се додељује новој листи, а на улазу се у зависности од \verb+swapNeeded+ елементи прослеђују у обрнутом или истом редоследу. Ако би се слично као у итеративној имплементацији прослеђивала \verb+Bool+ вредност \verb+swapNeeded+ модулу \verb+Swapper+, Чизел би пријавио грешку да не види ову вредност из модула \verb+Swapper+, па је на овај начин решен тај проблем.

\newpage
\subsection{Опис програма}

Сада ће бити описан програмски код имплементације изложене у овом раду:
\begin{enumerate}
\item \verb+Passthrough+ је једноставан модул који има два улазна порта \verb+a0+ и \verb+a1+ и два излазна порта \verb+z0+ и \verb+z1+. Прихвата два податка истог типа \verb+T+ и директно их рутира на излазне портове без измене.

\item Објекат \verb+BitonicSorter+ дефинише функције за имплементацију битоник сорт алгоритма.
\begin{itemize}
\item Функција \verb+bitonicMerge()+ прима низ елемената \verb+arr+, дужину низа \verb+length+, информацију о редоследу сортирања \verb+ascending+, и функцију за упоређивање два елемента \verb+lt()+.
\begin{itemize}
\item Ако је дужина низа \verb+arr+ 1 или мања, низ се сматра већ сортираним и враћа се без промена.
\item Ако је дужина низа већа од 1, низ се дели на две половине и за сваки пар елемената \verb-(i, i+length/2)- у низу се врши поређење и ако је потребно замењује се кроз модул \verb+Passthrough+. Након што се обаве сви кораци, сортиран низ се враћа као излаз функције.
\end{itemize}

\item Функција \verb+bitonicSort()+ прима низ елемената \verb+arr+ који треба сортирати, информацију о редоследу сортирања \verb+ascending+ - да ли је сортирање у растућем редоследу или не, и функцију за упоређивање два елемента \verb+lt+.
\begin{itemize}
 \item Ако је дужина низа \verb+arr+ 1 или мања, низ се сматра већ сортираним и враћа се без промена
 \item Ако је дужина низа већа од 1, врше се рекурзивни позиви половина низа у растућем и опадајућем редпоследу; а потом се две половине спајају користећи \verb+bitonicMerge()+. Након што се обаве сви кораци, сортиран низ се враћа као излаз функције.
\end{itemize}
\item Функција \verb+sort()+ проверава да ли је дужина улазног низа степен броја 2, и ако јесте, позива функцију \verb+bitonicSort()+ за извршење сортирања.
\end{itemize}
\begin{minted}{scala}
def bitonicSort[T<:Data](arr: IndexedSeq[Option[T]], ascending: Bool,
                      lt: (T, T) => Bool): IndexedSeq[Option[T]] = {
  val n = arr.length
  if (n > 1) {
    val half = n / 2
    val left = bitonicSort(arr.slice(0, half), true.B, lt)
    val right = bitonicSort(arr.slice(half, n), false.B, lt)
    val merged = bitonicMerge(left ++ right, n, ascending, lt)
    merged
  } else {
    arr
  }
}
\end{minted}
\item  Класа \verb+SorterModuleIfc+ дефинише интерфејс за модул битоник сортера. Као параметре прима број елемената за сортирање \verb+n+ и тип податка елемената \verb+proto+.

\item Класа \verb+BitonicSorterModule+ представља стварни модул битоник сортера који би се користио у хардверском дизајну.
\begin{itemize}
 \item Kао улазне параметре прихвата број елемената за сортирање \verb+n+, тип податка елемената \verb+proto+, флeг за редослед сортирања \verb+ascending+ и функцију за упоређивање \verb+lt+.
 \item Креира интерну секвенцу \verb+a+ која се користи за сортирање. Елементи ове секвенце се изводе из улазних података \verb+io.a+, обезбеђујући да дужина секвенце буде степен броја \verb+2+.
 \item Сортиран излаз се израчунава помоћу функције \verb+BitonicSorter.sort()+ и додељује се излазном порту \verb+io.z.+
\end{itemize}

\begin{minted}{scala}
  IndexedSeq.tabulate(if (n <= 1) 1 else 1 << log2Up(io.a.length)) {
    i => if (i < n) Some(io.a(i)) else None }
\end{minted}


\item Примери генерисања кода \verb+BitonicSorterUInt8_64Driver+ и \verb+BitonicSorterUInt8_384Driver+ демонстрирају како користити модул битоник сортера са конкретним конфигурацијама, тако што се креирају инстанце \verb+BitonicSorterModule+ са различитим параметрима (нпр.\ сортирају 64 елемента типа \verb+UInt(8)+ у растућем редоследу) и генеришу SystemVerilog код користећи \verb+ChiselStage+.

\end{enumerate}

\subsection{Тест за битоник сортер}
\hyperref[sec:d_prilog]{Прилог} садржи програмски код за тестирање описане рекурзивне имплементације битоник сортера.
Овај Чизел тест проверава \verb+BitonicSorterModule+ путем давања улазних вредности, померајући такт и обезбеђујући да излазне вредности буду сортиране у растућем редоследу. За тестирање се користи \verb+ChiselTest+ и \verb+ScalaTest+.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.45]{slike/testRes}
  \caption{Извршавање теста}
  \label{fig:testRes}
\end{figure}

\newpage
\subsection{Покретање програма}
У GitHub репозиториjуму \textit{BitonicSorterRecursive}, наведеном у литератури \cite{git_moje}, се налазе:
\begin{itemize}
\item Пројекат \textit{BitonicSorterRec}, који се може отворити у Intellij-у
\item \LaTeX{} код овог рада и pdf датотека
\end{itemize}

Покретање пројекта се врши извршавањем команде \verb+sbt test+ у директоријуму пројекта.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.5]{slike/struktura}
  \caption{Структура пројекта}
  \label{fig:struktura}
\end{figure}

Слика \ref{fig:struktura} приказује структуру пројекта, \verb+BitonicSorterModule.scala+ се налази у директоријуму \verb+/src/main/scala/+, a \verb+BitonicSorterModuleTest.scala+ у \verb+/src/test/scala/+.
Слика \ref{fig:testRes} приказује резултат извршавања теста.

\newpage
\subsection{Приказ добијеног кола}

Слика \ref{fig:visualizeRec} прикатује генерисано коло овако имплементираног битоник сортера и на први поглед изгледа сложеније него коло имплементирано итеративним приступом.

\begin{figure}[H]
  \centering
      \includegraphics[scale=0.31]{slike/visualizeRec.png}
  \caption{Приказ реурзивне имплементације}
  \label{fig:visualizeRec}
\end{figure}

Програмски код итеративне имплементације модул \verb+Swapper+ независно врши замену елемената, док су овде у замену укључени модул \verb+Passthrough+, функција поређења \verb+lt()+, \verb+ascending+ и може се видети негација \verb+not+; али су то су елементи који се понављају.

\newpage
\section{Закључак}

Током израде је било потребно разумети начин рада постојећих решења да би се превазишле одрећене разлике и ограничења у програмирању коришћењем програмских језика и језика за опис хардвера. Чизел свакако олакшава превазилажење ових препрека, и донекле дозвољава апстрактније размишљање, јер се ипак овај претвара у Верилог, па се може рећи да је језик вишег нивоа.

Визуелно су приказана генерисана кола и може се видети да рекурзивно решење изнето у овом раду захтева више елемената у односу на итераривно. Оба решења имају врло сажет програмски код.

%Несумњиво је да Чизел пружа могућност ефикаснијег куцања кода и једноставнијег описа хардвера.

%\newpage
\clearpage
\begingroup
\raggedright
%\bibliography{srpski_Literatura}


\begin{thebibliography}{99}

\bibitem{wiki_scala}
\textit{Scala (programming language)}, приступљено (август 2023.) на
\url{https://en.wikipedia.org/wiki/Scala_(programming_language)}

\bibitem{odersky2016}
  Martin Odersky, Lex Spoon, and Bill Venners,
  ``Programming in Scala, Third Edition'',
  Artima, 2016.

\bibitem{courseraHOF}
Martin Odersky, \textit{Higher-order functions}, [Интернет курс] \textit{Functional Programming Principles in Scala}, приступљено (август 2023.) на
\url{https://www.coursera.org/learn/scala-functional-programming/lecture/V5crF/lecture-2-1-higher-order-functions}

\bibitem{wiki_chisel}
\textit{Chisel (programming language)}, приступљено (август 2023.) на
\url{https://en.wikipedia.org/wiki/Chisel_(programming_language)}

% \bibitem{berkeley_twigg}
%   Stephen Twigg,
%   "Flexible FFT Optimization and RTL Generation in the Chisel Hardware Design Language" [Мастер рад, Универзитет у Калифорнији, Беркли],
%   Artima, 2016.

\bibitem{berkeley_twigg}
  Stephen Twigg,
  ``Flexible FFT Optimization and RTL Generation in the Chisel Hardware Design Language'', [Мастер рад, Универзитет у Калифорнији, Беркли], 2015.
  \url{http://www2.eecs.berkeley.edu/Pubs/TechRpts/2015/EECS-2015-256.html}

\bibitem{git_chisel}
\textit{Chisel Bootcamp}, приступљено (август 2023.) на
\url{https://github.com/freechipsproject/chisel-bootcamp.git}

\bibitem{zuluaga2016}
  Marcela Zuluaga, Peter Milder, and Markus Püschel,
  ``Streaming sorting networks'',
  ACM Trans.\ Des.\ Autom.\ Electron.\ Syst.\ 21, 4, чланак 55, 2016.
  \verb+DOI+:\url{http://dx.doi.org/10.1145/2854150}

\bibitem{bitonicBatcher}
  K.\ E.\ Batcher,
  ``Sorting networks and their applications'',
  ACM, 1968.
  \verb+DOI+:\url{http://dx.doi.org/10.1145/1468075.1468121}

\bibitem{wiki_bitonic}
\textit{Bitonic sorter}, приступљено (август 2023.) на
\url{https://en.wikipedia.org/wiki/Bitonic_sorter}

\bibitem{git_freeChipsBitonic}
Steve Burns,
\textit{Bitonic Sorter}, приступљено (септембар 2023.) на
\url{https://github.com/freechipsproject/ip-contributions/tree/master/src/main/scala/chisel/lib/bitonicsorter}

\bibitem{geeks}
\textit{Bitonic Sort}, приступљено (септембар 2023.) на
\url{https://www.geeksforgeeks.org/bitonic-sort/}

\bibitem{git_moje}
\textit{BitonicSorterRecursive}, приступљено (септембар 2023.) на
\url{https://github.com/aleksavelickovic5762015/BitonicSorterRecursive.git}

\end{thebibliography}

\endgroup

\newpage

\section*{Списак скраћеница}
\addcontentsline{toc}{section}{Списак скраћеница}
\begin{acronym}
\acro{fvr}[ФВР]{Функције вишег реда}
\end{acronym}

\listoftables

\newpage

\listoffigures

\newpage

\section*{Прилог}
\addcontentsline{toc}{section}{Прилог}

\subsection*{А.\ Итеративна имплементација - Чизел}
\addcontentsline{toc}{subsection}{А.\ Итеративна имплементација - Чизел}
\label{sec:a_prilog}

У наставку је приказана итеративна имплементација битоник сортера \cite{git_freeChipsBitonic}.
\begin{minted}{scala}
 // See README.md for license details.

package chisel.lib.bitonicsorter

import chisel3._
import chisel3.stage.ChiselStage
import chisel3.util._

/**
  * Builds a mux whose that tests its two inputs
  * Construct hardware to swap inputs to outputs or pass them straight through
  * depending on comparison function
  * otherwise
  * @param proto  The type generator for the swapper
  * @param lt     The comparision function
  * @tparam T     The type of the inputs and outputs, derived from proto
  */
class Swapper[T <: Data](proto: T, lt: (T, T) => Bool) extends Module {
  val io = IO(new Bundle {
    val a0 = Input(proto)
    val a1 = Input(proto)
    val z0 = Output(proto)
    val z1 = Output(proto)
  })
  when(lt(io.a1, io.a0)) {
    io.z0 := io.a1
    io.z1 := io.a0
  }.otherwise {
    io.z0 := io.a0
    io.z1 := io.a1
  }
}

/**
  * Bitonic Sorter is a factory for combinational sort hardware.
  * It requires that the elements to be sorted are a power of 2.
  *
  * @see https://en.wikipedia.org/wiki/Bitonic_sorter
  */
object BitonicSorter {
  def apply[T <: Data](a: IndexedSeq[Option[T]], factory: () => Swapper[T]):
                                                  IndexedSeq[Option[T]] = {
    assert((1 << log2Up(a.length)) == a.length)
    def insertSorter(a: IndexedSeq[Option[T]], lo: Int, hi: Int):
                                                  IndexedSeq[Option[T]] = {
      (a(lo), a(hi)) match {
        case (_, None)        => a
        case (None, Some(aH)) => a.updated(lo, Some(aH)).updated(hi, None)
        case (Some(aL), Some(aH)) =>
          val m = Module(factory())
          m.io.a0 := aL
          m.io.a1 := aH
          a.updated(lo, Some(m.io.z0)).updated(hi, Some(m.io.z1))
      }
    }
    (for {
      i <- 0 until log2Up(a.length)
      j <- i to 0 by -1
      k0 <- a.indices by (2 << j)
      k1 <- 0 until 1 << j
    } yield {
      val lo = k0 + k1
      val hi = lo + (1 << j)
      if ((lo >> (i + 1)) % 2 == 0) (lo, hi) else (hi, lo)
    }).foldLeft(a) { case (s, (l, h)) => insertSorter(s, l, h) }
  }
}

/**
  * Defines the interface used for the Bitonic Sort module
  * @param n      The number of elements
  * @param proto  An instance of the type of all elements
  * @tparam T     The type as derived from proto
  */
class SorterModuleIfc[T <: Data](val n: Int, proto: T) extends Module {
  val io = IO(new Bundle {
    val a = Input(Vec(n, proto.cloneType))
    val z = Output(Vec(n, proto.cloneType))
  })
}

/*
 * What follows are some example code generation calls.
 */

class BitonicSorterModule[T <: Data](n: Int, proto: T, lt: (T, T) => Bool)
                                        extends SorterModuleIfc(n, proto) {
  private val a = IndexedSeq.tabulate(1 << log2Up(io.a.length))
                            { i => if (i < n) Some(io.a(i)) else None }
  io.z := VecInit(BitonicSorter(a, () => new Swapper(proto.cloneType, lt))
                                                .slice(0, n).map(_.get))
}

//scalastyle:off magic.number
object BitonicSorterUInt8_64Driver extends App {
  (new ChiselStage).emitSystemVerilog(new BitonicSorterModule(64, UInt(8.W),
                                        (x: UInt, y: UInt) => x < y), args)
}

//scalastyle:off magic.number
object BitonicSorterUInt8_384Driver extends App {
  (new ChiselStage).emitSystemVerilog(new BitonicSorterModule(384, UInt(8.W),
                                        (x: UInt, y: UInt) => x < y), args)
}

\end{minted}


\subsection*{Б.\ Рекурзивна имплементација - Пајтон}
\addcontentsline{toc}{subsection}{Б.\ Рекурзивна имплементација - Пајтон}
\label{sec:b_prilog}

У наставку је приказана рекурзивна имплементација битоник сортера у \mbox{Пајтону \cite{geeks}}.

\begin{minted}{python}
def compAndSwap(a, i, j, dire):
  if (dire==1 and a[i] > a[j]) or (dire==0 and a[i] < a[j]):
    a[i],a[j] = a[j],a[i]

def bitonicMerge(a, low, cnt, dire):
  if cnt > 1:
    k = cnt//2
    for i in range(low , low+k):
        compAndSwap(a, i, i+k, dire)
    bitonicMerge(a, low, k, dire)
    bitonicMerge(a, low+k, k, dire)

def bitonicSort(a, low, cnt,dire):
  if cnt > 1:
    k = cnt//2
    bitonicSort(a, low, k, 1)
    bitonicSort(a, low+k, k, 0)
    bitonicMerge(a, low, cnt, dire)

def sort(a,N, up):
  bitonicSort(a,0, N, up)

a = [3, 7, 4, 8, 6, 2, 1, 5]
n = len(a)
up = 1

sort(a, n, up)
\end{minted}

\subsection*{В.\ Рекурзивна имплементација у Чизелу - резултат рада}
\addcontentsline{toc}{subsection}{В.\ Рекурзивна имплементација у Чизелу - резултат рада}
\label{sec:c_prilog}

У наставку је приказана рекурзивна имплементација битоник сортера у Чизелу која је резултат овог рада.

\begin{minted}{scala}
// See README.md for license details.

import chisel3._
import chisel3.stage.ChiselStage
import chisel3.util._

/**
 * Simple Passthrough module
 * @param proto  The type generator for the swapper
 * @tparam T     The type of the inputs and outputs, derived from proto
 */
class Passthrough[T <: Data](proto: T) extends Module {
  val io = IO(new Bundle {
    val a0 = Input(proto)
    val a1 = Input(proto)
    val z0 = Output(proto)
    val z1 = Output(proto)
  })

  io.z0 := io.a0
  io.z1 := io.a1

}

/**
 * Bitonic Sorter is a factory for combinational sort hardware.
 * It requires that the elements to be sorted are a power of 2.
 *
 * @see https://en.wikipedia.org/wiki/Bitonic_sorter
 */
object BitonicSorter {
  def bitonicMerge[T <: Data](arr: IndexedSeq[Option[T]], length: Int,
            ascending: Bool, lt: (T, T) => Bool): IndexedSeq[Option[T]] = {
    def swapIfNecessary(seq: IndexedSeq[Option[T]], i: Int,
            ascending: Bool, lt: (T, T) => Bool): IndexedSeq[Option[T]] = {
      val j = i + length / 2
      val si = arr(i).getOrElse(0.U.asTypeOf(arr(i).get))
      val sj = arr(j).getOrElse(0.U.asTypeOf(arr(j).get))
      val m = Module(new Passthrough(si.cloneType))
      val swapNeeded = lt(sj, si) === ascending
      when(swapNeeded) {
        m.io.a0 := sj
        m.io.a1 := si
      }.otherwise {
        m.io.a0 := si
        m.io.a1 := sj
      }
      seq.updated(i, Some(m.io.z0)).updated(j, Some(m.io.z1))
    }

    if (length > 1) {
      val half = length / 2
      val indices = 0 until half

      val swappedSeq = indices.foldLeft(arr) { (seq, i) =>
        swapIfNecessary(seq, i, ascending, lt)
      }

      val left = bitonicMerge(swappedSeq.slice(0, half),
                                          half, ascending, lt)
      val right = bitonicMerge(swappedSeq.slice(half, length),
                                          half, ascending, lt)
      left ++ right
    }
    else {
      arr
    }
  }

  def bitonicSort[T <: Data](arr: IndexedSeq[Option[T]], ascending: Bool,
                          lt: (T, T) => Bool): IndexedSeq[Option[T]] = {
    val n = arr.length
    if (n > 1) {
      val half = n / 2
      val left = bitonicSort(arr.slice(0, half), true.B, lt)
      val right = bitonicSort(arr.slice(half, n), false.B, lt)
      val merged = bitonicMerge(left ++ right, n, ascending, lt)
      merged
    } else {
      arr
    }
  }

  def sort[T <: Data](a: IndexedSeq[Option[T]], ascending: Bool = true.B,
                          lt: (T, T) => Bool): IndexedSeq[Option[T]] = {
    if (a.length <= 1) {
      // Nothing to sort, return the input array
      a
    }
    else {
      assert((1 << log2Up(a.length)) == a.length,
                  "Array length must be a power of 2")
      val sortedArray = bitonicSort(a, ascending, lt)
      sortedArray
    }
  }
}

/**
 * Defines the interface used for the Bitonic Sort module
 * @param n      The number of elements
 * @param proto  An instance of the type of all elements
 * @tparam T     The type as derived from proto
 */
class SorterModuleIfc[T <: Data](val n: Int, proto: T) extends Module {
  val io = IO(new Bundle {
    val a = Input(Vec(n, proto.cloneType))
    val z = Output(Vec(n, proto.cloneType))
  })
}

/*
 * What follows are some example code generation calls.
 */

class BitonicSorterModule[T <: Data](n: Int, proto: T, ascending: Bool,
                    lt: (T, T) => Bool) extends SorterModuleIfc(n, proto) {
  private val a = IndexedSeq.tabulate(
    if (n <= 1) 1 else 1 << log2Up(io.a.length)) { i =>
      if (i < n) Some(io.a(i)) else None }
  io.z := VecInit(BitonicSorter.sort(a, ascending, lt).map(_.get))
}

object BitonicSorterUInt8_64Driver extends App {
  (new ChiselStage).emitSystemVerilog(new BitonicSorterModule(64, UInt(8.W),
                                true.B, (x: UInt, y: UInt) => x < y), args)
}

object BitonicSorterUInt8_384Driver extends App {
  (new ChiselStage).emitSystemVerilog(new BitonicSorterModule(384, UInt(8.W),
                                true.B, (x: UInt, y: UInt) => x < y), args)
}


\end{minted}

\newpage
\subsection*{Г.\ Програмски код за тестирање битоник сортера}
\addcontentsline{toc}{subsection}{Г.\ Програмски код за тестирање битоник сортера}
\label{sec:d_prilog}

У наставку је приказана програм за тестирање описане рекурзивне имплементације битоник сортера.

\begin{minted}{scala}
import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

class BitonicSorterModuleTest extends AnyFlatSpec
                                  with ChiselScalatestTester {
  "BitonicSorterModule" should "sort input values in ascending order" in {
    test(new BitonicSorterModule(8, UInt(8.W), true.B,
                                (x: UInt, y: UInt) => x < y)) { dut =>
      val input = Seq(5, 8, 3, 1, 6, 2, 7, 4).map(_.U)

      dut.io.a.zipWithIndex.foreach { case (inputPort, index) =>
        inputPort.poke(input(index))
      }

      dut.clock.step()

      // Check if the output values are in ascending order
      var prevValue = BigInt(0)
      dut.io.z.foreach { outputPort: UInt =>
        val value = outputPort.peek().litValue.toInt
        println(value)
        outputPort.expect(value.U)
        assert(value >= prevValue,
                  "Output values are not in ascending order.")
        prevValue = value
      }
    }
  }
}
\end{minted}


\end{document}
